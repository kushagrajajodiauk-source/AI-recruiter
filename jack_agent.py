import os
import sys
import time
import re
from groq import Groq
from dotenv import load_dotenv
import speech_recognition as sr
import pyttsx3

# Load environment variables
load_dotenv()

# Global Groq client
client = None

def init_groq():
    """Initialize Groq client"""
    global client
    api_key = os.getenv("GROQ_API_KEY")
    if not api_key:
        print("Error: GROQ_API_KEY not found in environment variables.")
        print("Please create a .env file with GROQ_API_KEY=your_key")
        sys.exit(1)
    client = Groq(api_key=api_key)
    return client

def groq_call(messages, model="llama-3.3-70b-versatile", temperature=0.7):
    """Helper to call Groq API"""
    response = client.chat.completions.create(
        model=model,
        messages=messages,
        temperature=temperature
    )
    return response.choices[0].message.content

def load_system_prompt():
    try:
        with open("prompts/jack_persona.md", "r", encoding="utf-8") as f:
            return f.read()
    except FileNotFoundError:
        print("Error: prompts/jack_persona.md not found.")
        sys.exit(1)

def init_engine():
    """Initializes the TTS engine with male voice and natural speed."""
    engine = pyttsx3.init()
    
    # Set Rate (Speed) - Default for natural feel
    rate = engine.getProperty('rate')
    engine.setProperty('rate', rate) 
    
    # Set Voice (Male)
    voices = engine.getProperty('voices')
    target_voice = None
    
    # Look for "David" (common Windows male voice) or just "Male"
    for voice in voices:
        if "david" in voice.name.lower() or "male" in voice.name.lower():
            target_voice = voice.id
            break

    if target_voice:
        engine.setProperty('voice', target_voice)
            
    return engine

def speak(text):
    """Speaks the text using a fresh engine instance."""
    try:
        # Clean text for speech: remove markdown symbols and ALL asterisks
        clean_text = re.sub(r'\*.*?\*', '', text)  # Remove *text*
        clean_text = clean_text.replace("*", "")  # Remove any remaining asterisks
        clean_text = clean_text.replace("#", "").replace("- ", "")
        
        print(f"[Debug] Speaking: {clean_text[:50]}...")
        engine = init_engine()
        engine.say(clean_text)
        engine.runAndWait()
        print("[Debug] Speech finished.")
    except Exception as e:
        print(f"Error in TTS: {e}")

def listen():
    """Listens to the microphone and returns text."""
    r = sr.Recognizer()
    r.pause_threshold = 2.5  # Wait 2.5 seconds before processing (to avoid cutting off mid-sentence)
    
    with sr.Microphone() as source:
        print("\nListening... (Speak now)")
        # Adjust for ambient noise - reduced duration for faster response
        r.adjust_for_ambient_noise(source, duration=0.3)
        try:
            # Removed phrase_time_limit to allow longer, uninterrupted speech
            audio = r.listen(source, timeout=10, phrase_time_limit=None)
            print("Recognizing...")
            text = r.recognize_google(audio)
            print(f"You said: {text}")
            return text
        except sr.WaitTimeoutError:
            message = "I can't hear you. Could you please repeat that?"
            print(f"Jack: {message}")
            speak(message)
            return None
        except sr.UnknownValueError:
            message = "I didn't catch that. Could you say it again?"
            print(f"Jack: {message}")
            speak(message)
            return None
        except sr.RequestError as e:
            print(f"Could not request results; {e}")
            return None

def load_job_requirements():
    """Loads the job requirements generated by Jill if they exist."""
    try:
        if os.path.exists("job_requirements.md"):
            with open("job_requirements.md", "r", encoding="utf-8") as f:
                return f.read().strip()
    except Exception as e:
        print(f"Warning: Could not read job_requirements.md: {e}")
    return None

def load_cv_input():
    """Loads the candidate's CV from cv_input.txt if it exists, then deletes it."""
    try:
        if os.path.exists("cv_input.txt"):
            with open("cv_input.txt", "r", encoding="utf-8") as f:
                content = f.read().strip()
            
            # Auto-delete to prevent reuse by next user
            try:
                os.remove("cv_input.txt")
                print("‚úÖ Found and loaded cv_input.txt (File deleted for security)")
            except Exception as del_e:
                print(f"‚ö†Ô∏è Loaded cv_input.txt but failed to delete it: {del_e}")
                
            return content
    except Exception as e:
        print(f"Warning: Could not read cv_input.txt: {e}")
    return None

def generate_candidate_profile(messages, job_role=None, cv_content=None):
    """Generates a candidate profile document based on the conversation and optional CV."""
    print("\nüìù Generating Candidate Profile One-Pager...")
    try:
        # Load system prompt for generation context
        try:
            with open("prompts/jack_persona.md", "r", encoding="utf-8") as f:
                persona_prompt = f.read()
        except:
            persona_prompt = "You are an expert technical recruiter."

        role_context = f" for the role of {job_role}" if job_role else ""
        
        # Add CV cross-reference if provided
        cv_context = ""
        if cv_content:
            cv_context = f"""

IMPORTANT: The candidate has also provided their CV/Resume. Use this to:
1. Cross-reference factual details (dates, job titles, education)
2. Fill in any gaps from the conversation
3. Validate what they told you
4. Add any additional relevant details they didn't mention

CANDIDATE'S CV:
---
{cv_content}
---

If there are any discrepancies between the conversation and CV, note them in the profile.
"""
        
        prompt =f"""Based on our comprehensive conversation{role_context}, please generate a detailed Candidate Profile One-Pager. 
        {cv_context} 
        
        Include ALL of the following sections:
        - **Professional Summary** (Who they are, years of experience, specialization)
        - **Educational Background** (Degrees, universities, graduation years, certifications, relevant training)
        - **Work Experience Timeline** (List previous roles chronologically with: Company, Title, Duration, Key Responsibilities, Notable Accomplishments, Reason for Leaving)
        - **Current Role & Responsibilities** (What they do day-to-day, current projects)
        - **Key Projects & Achievements** (Specific examples with measurable impact)
        - **Hard Skills & Expertise** (Technical skills, tools, technologies with proficiency levels and years of experience)
        - **Passions & Interests** (What drives them professionally, what excites them)
        - **Target Industries** (Specific industries they're interested in, e.g., fintech, AI, healthcare, climate tech)
        - **Target Companies or Company Types** (e.g., "early-stage startups," "FAANG," "Fortune 500," specific companies mentioned)
        - **Preferred Role Types** (e.g., "hands-on IC," "people manager," "technical lead," "startup vs enterprise")
        - **Industry Insights** (Problems they identified in their industry and how they'd solve them - shows strategic thinking)
        - **Behavioral Traits & Strengths** (Deduced from their scenario responses: teamwork style, leadership capabilities, conflict resolution, handling pressure, problem-solving approach, initiative, learning from failure, resilience)
        - **Cultural Fit Profile** (Ideal work environment, preferred management style, company culture that helps them thrive, dealbreakers/red flags)
        - **Fit for Role** (If a specific role was provided, analyze how well they fit. Otherwise, provide general career guidance and role recommendations)
        - **Salary & Logistics** (Salary expectations with base + bonus breakdown, location preferences, remote/hybrid/on-site preference, availability to start)
        
        CRITICAL: At the very beginning, include a line: "CANDIDATE_NAME: [their full name]"
        
        CRITICAL: At the very beginning, include a line: "CANDIDATE_NAME: [their full name]"
        
        Format it as a concise **ONE-PAGE SUMMARY**. Do not write a multi-page essay.
        Use bullet points and short paragraphs. Make it a clean, professional Markdown document.
        Be specific and cite examples from our conversation. For behavioral traits, reference the specific scenarios they shared.
        # Call Groq to generate
        gen_messages = [
            {"role": "system", "content": persona_prompt},
            {"role": "user", "content": prompt}
        ]
        
        content = groq_call(gen_messages, model="llama-3.3-70b-versatile")
        candidate_name = "unknown"
        for line in content.split('\n'):
            if 'CANDIDATE_NAME:' in line:
                candidate_name = line.split('CANDIDATE_NAME:')[1].strip()
                # Remove this line from the content
                content = content.replace(line, "").strip()
                break
        
        # Sanitize name for filename
        import re
        from datetime import datetime
        safe_name = re.sub(r'[^\w\s-]', '', candidate_name.lower())
        safe_name = re.sub(r'[-\s]+', '_', safe_name)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Ensure candidates directory exists
        os.makedirs("candidates", exist_ok=True)
        
        filename = f"candidates/candidate_{safe_name}_{timestamp}.md"
        with open(filename, "w", encoding="utf-8") as f:
            f.write(content)
            
        print(f"‚úÖ Candidate profile saved to {filename}")
        
        # Persist to Database
        try:
            from database import add_candidate
            # Extract name from filename or use safe_name
            db_name = safe_name.replace("_", " ").title()
            
            # Extract basic skills/prefs (simplified for now, ideally parsed from content)
            # For now we'll pass the whole content as the profile source
            add_candidate(
                name=db_name,
                profile_file=filename,
                skills=[],  # TODO: extract skills from profile
                preferences={}  # TODO: extract prefs from profile
            )
            print(f"‚úÖ Candidate added to database: {db_name}")
        except Exception as db_e:
            print(f"‚ùå Error adding to database: {db_e}")
            
        return filename, content
    except Exception as e:
        print(f"‚ùå Error generating candidate profile: {e}")
        return None, None

def check_for_job_matches(model, candidate_profile_content):
    """Check if candidate matches any available jobs."""
    # Logic moved to run_recruiting_loop.py
    # from messaging import get_all_job_specs, send_message
    pass
    
    if not job_files:
        print("\nüì≠ No job specs available from Jill yet.")
        return
    
    print(f"\nüîç Checking candidate against {len(job_files)} available job(s)...")
    
    for job_file in job_files:
        try:
            with open(job_file, "r", encoding="utf-8") as f:
                job_content = f.read()
            
            # Use Gemini to analyze match
            match_prompt = f"""Analyze this candidate profile against the job requirements.
            
CANDIDATE PROFILE:
---
{candidate_profile_content}
---

JOB REQUIREMENTS:
---
{job_content}
---

Provide:
1. Match Score (0.0-1.0, where 1.0 is perfect match)
2. Brief explanation of fit
3. Key strengths for this role
4. Potential gaps or concerns

Format: Start with "MATCH_SCORE: X.XX" then your analysis."""

            response = model.generate_content(match_prompt)
            analysis = response.text
            
            # Extract score
            score_line = [line for line in analysis.split('\n') if 'MATCH_SCORE' in line]
            match_score = 0.0
            if score_line:
                try:
                    match_score = float(score_line[0].split(':')[1].strip())
                except:
                    match_score = 0.5
            
            # Send match suggestion to Jill if score is decent
            if match_score >= 0.6:
                message = f"""üéØ CANDIDATE MATCH SUGGESTION

I think this candidate could be a good fit for the role in {job_file}!

Match Score: {match_score:.2f}/1.0

{analysis}

Let me know if you'd like me to reach out to the candidate about this opportunity!"""

                send_message("Jack", "Jill", "match_suggestion", message, {
                    "candidate_file": "candidate_profile.md",
                    "job_file": job_file,
                    "match_score": match_score
                })
                
                print(f"‚úÖ Sent match suggestion to Jill (Score: {match_score:.2f})")
            else:
                print(f"‚ö†Ô∏è  Low match for {job_file} (Score: {match_score:.2f}) - not suggesting")
                
        except Exception as e:
            print(f"Error analyzing match for {job_file}: {e}")


def main():
    # Initialize Groq
    init_groq()

    system_prompt = load_system_prompt()
    
    # Initialize database
    from database import init_database, get_agent_messages, mark_message_read, add_candidate
    init_database()
    
    # Read messages from Jill (legacy system) - REMOVED
    # from messaging import read_messages
    # print("\nüì¨ Checking messages from Jill...")
    # messages = read_messages("Jack")
    
    # if messages:
    #     print(f"\nüí¨ You have {len(messages)} new message(s) from Jill:\n")
    #     for msg in messages:
    #         print(f"[{msg['timestamp']}] {msg['type'].replace('_', ' ').title()}:")
    #         print(f"{msg['content']}\n")
    #         print("---\n")
    # else:
    #     print("No new messages from Jill.\n")
    
    # Check for Scout recommendations (new system)
    print("üîç Checking Scout recommendations...")
    scout_messages = get_agent_messages("Jack", unread_only=True)
    
    if scout_messages:
        print(f"\nüéØ Scout found {len(scout_messages)} recommendation(s):\n")
        for msg in scout_messages:
            import json
            metadata = json.loads(msg['metadata']) if msg['metadata'] else {}
            print(f"   [{msg['message_type']}] {msg['content']}")
            
            # If it's a candidate recommendation, show candidates and offer outreach
            if msg['message_type'] == 'candidate_recommendation':
                candidates = metadata.get('candidates', [])
                job_title = metadata.get('job_title', 'Unknown Role')
                print(f"   Job: {job_title}")
                print(f"   Found {len(candidates)} candidates:")
                for c in candidates[:3]:  # Show first 3
                    print(f"      ‚Ä¢ {c.get('name', 'Unknown')} - {c.get('headline', '')[:40]}...")
                print()
            
            # If it's a job recommendation for a candidate
            elif msg['message_type'] == 'job_recommendation':
                jobs = metadata.get('jobs', [])
                candidate_name = metadata.get('candidate_name', 'Unknown')
                print(f"   Candidate: {candidate_name}")
                print(f"   Found {len(jobs)} matching jobs:")
                for j in jobs[:3]:
                    print(f"      ‚Ä¢ {j.get('title', 'Unknown')[:40]}...")
                print()
            
            mark_message_read(msg['id'])
        
        print("   üí° Run `python linkedin_outreach.py` to generate outreach messages.\n")
    else:
        print("No new Scout recommendations.\n")
    
    # Check for inputs
    job_requirements = load_job_requirements()
    cv_input = load_cv_input()
    
    # Use Groq's Llama model for fast responses
    model_name = "llama-3.3-70b-versatile"
    
    try:
        # Initialize conversation history for Groq
        messages = [{"role": "system", "content": system_prompt}]
        
        # Build better intro message
        intro_text = "Hey! I'm Jack, your Talent Advocate. I'm here to help you land your next amazing role. Let's talk about your experience and what you're looking for. Tell me - what kind of work have you been doing lately?"
        
        if job_requirements:
            intro_text = "Hey! I'm Jack. I'm currently helping fill a specific role, and I'd love to chat with you about it. But first, tell me about yourself - what's your background?"
            messages.append({"role": "user", "content": f"CONTEXT: You are recruiting for this role:\n{job_requirements}"})
            ack = groq_call(messages, model_name)
            messages.append({"role": "assistant", "content": ack})
        elif cv_input:
            intro_text = "Hi! I'm Jack, your Talent Advocate. I've got your CV here - let's dive into your experience. Tell me about your most recent role and what you loved about it!"
            messages.append({"role": "user", "content": f"CONTEXT: Candidate provided this CV:\n{cv_input}"})
            ack = groq_call(messages, model_name)
            messages.append({"role": "assistant", "content": ack})

        print(f"Jack (Talent Advocate) [{model_name}]: {intro_text}")
        speak(intro_text)

        while True:
            try:
                user_input = listen()
                
                if not user_input:
                    continue

                # Check for exit keywords BEFORE sending to AI
                if user_input.lower() in ['quit', 'exit', 'stop', 'goodbye']:
                    # DON'T send "goodbye" to the AI, handle it directly
                    cv_content = cv_input
                    
                    if not cv_content:
                        # Ask for CV upload ONLY if not provided at start
                        cv_request = "Great interview! One more thing - do you have a CV or resume you'd like to share? This will help me create a more accurate profile by cross-referencing what we discussed. If yes, please paste your CV text into a file called 'candidate_cv.txt' in this directory and then say 'ready'. If not, just say 'no' or 'skip'."
                        print(f"\nJack: {cv_request}")
                        speak(cv_request)
                        
                        # Wait for response
                        cv_response = listen()
                        
                        if cv_response and cv_response.lower() in ['ready', 'yes', 'done', 'uploaded']:
                            # Try to read CV
                            if os.path.exists("candidate_cv.txt"):
                                try:
                                    with open("candidate_cv.txt", "r", encoding="utf-8") as f:
                                        cv_content = f.read()
                                    confirm_msg = "Thanks! I've got your CV. I'll use this to cross-reference our conversation."
                                    print(f"\nJack: {confirm_msg}")
                                    speak(confirm_msg)
                                    
                                    # Delete CV file immediately to prevent reuse
                                    os.remove("candidate_cv.txt")
                                    print("‚úÖ CV processed and file deleted")
                                except Exception as e:
                                    print(f"‚ö†Ô∏è Couldn't read CV file: {e}")
                            else:
                                wait_msg = "I don't see the candidate_cv.txt file yet. Let me know when it's ready by saying 'ready'."
                                print(f"\nJack: {wait_msg}")
                                speak(wait_msg)
                                
                                # Give one more chance
                                second_response = listen()
                                if second_response and os.path.exists("candidate_cv.txt"):
                                    try:
                                        with open("candidate_cv.txt", "r", encoding="utf-8") as f:
                                            cv_content = f.read()
                                        os.remove("candidate_cv.txt")
                                        print("‚úÖ CV processed and file deleted")
                                    except Exception as e:
                                        print(f"‚ö†Ô∏è Couldn't read CV file: {e}")
                    
                        if not cv_content:
                            no_cv_msg = "No problem! I'll create your profile based on our conversation."
                            print(f"\nJack: {no_cv_msg}")
                            speak(no_cv_msg)
                    
                    # Generate Profile with optional CV cross-reference
                    result = generate_candidate_profile(messages, job_role="Target Role" if job_requirements else None, cv_content=cv_content)
                    
                    if result and result[0]:
                        filename, profile_content = result
                        
                        # Approval loop - allow iterative refinement
                        while True:
                            # Show the document to user (don't read it aloud)
                            print("\n" + "="*60)
                            print("üìÑ CANDIDATE PROFILE GENERATED")
                            print("="*60)
                            print(profile_content)
                            print("="*60)
                            
                            # Ask for approval - REMOVED (Auto-save now)
                            # approval_message = "I've generated your candidate profile above..."
                            # print(f"\nJack: {approval_message}")
                            # speak(approval_message)
                            
                            # Wait for approval - REMOVED (Auto-save now)
                            approval = "yes"  # Auto-approve
                            
                            if approval and approval.lower() in ['yes', 'yeah', 'yep', 'sure', 'approve', 'good', 'looks good', 'perfect']:
                                # Save and share - REMOVED legacy messaging
                                # from messaging import send_message
                                
                                # Overwrite file with latest content (already saved by generate_candidate_profile)
                                # with open(filename, "w", encoding="utf-8") as f:
                                #     f.write(profile_content)
                                
                                # send_message(...) - REMOVED
                                
                                print(f"üì§ Saved candidate profile (Jill will see it in the DB)")
                                
                                # Check for matches
                                check_for_job_matches(model, profile_content)
                                
                                success_msg = "Great! I've saved your profile and shared it with Jill. She'll match you with suitable opportunities. Best of luck, and goodbye!"
                                print(f"\nJack: {success_msg}")
                                speak(success_msg)
                                break  # Exit approval loop
                            else:
                                # Ask for changes
                                changes_msg = "No problem! What would you like me to change or add to your profile?"
                                print(f"\nJack: {changes_msg}")
                                speak(changes_msg)
                                
                                # Get user feedback
                                feedback = listen()
                                
                                if not feedback:
                                    continue
                                
                                # Generate updated version
                                update_prompt = f"""The candidate wants changes to their profile. Here's the current version:

---
{profile_content}
---

Candidate feedback: {feedback}

Please generate an UPDATED version incorporating their feedback. Keep the same format and structure, but make the requested changes. Include the "CANDIDATE_NAME: [name]" line at the beginning."""

                                print("\nüîÑ Updating candidate profile...")
                                update_messages = [{"role": "system", "content": system_prompt}, {"role": "user", "content": update_prompt}]
                                
                                # Extract updated content
                                updated_content = groq_call(update_messages)
                                for line in updated_content.split('\n'):
                                    if 'CANDIDATE_NAME:' in line:
                                        updated_content = updated_content.replace(line, "").strip()
                                        break
                                
                                profile_content = updated_content
                                print("‚úÖ Updated!")
                                # Loop back to show updated version
                    else:
                        error_msg = "I had trouble generating your profile. Let me know if you'd like to try again. Goodbye!"
                        print(f"Jack: {error_msg}")
                        speak(error_msg)
                    break  # Exit main conversation loop

                messages.append({"role": "user", "content": user_input})
                ai_response = groq_call(messages, model_name)
                messages.append({"role": "assistant", "content": ai_response})
                print(f"\nJack: {ai_response}")
                speak(ai_response)
            except KeyboardInterrupt:
                print("\nJack: Goodbye!")
                break
            except Exception as e:
                print(f"\nAn error occurred during chat: {e}")

    except Exception as e:
        print(f"\nError initializing model '{model_name}': {e}")
        print("\nListing available models...")
        try:
            with open("models.txt", "w") as f:
                for m in genai.list_models():
                    if 'generateContent' in m.supported_generation_methods:
                        print(f"- {m.name}")
                        f.write(f"{m.name}\n")
            print("Models written to models.txt")
        except Exception as list_e:
            print(f"Could not list models: {list_e}")
        print("\nPlease update the 'model_name' in jack_agent.py to one of the available models above.")

if __name__ == "__main__":
    main()
